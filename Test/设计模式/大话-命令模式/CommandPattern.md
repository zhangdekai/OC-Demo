#  命令模式（Command Pattern）

命令模式（Command Pattern）是一种行为型设计模式，

**它将请求封装为一个对象（命令对象），使发送者（发起请求的对象）与接收者（执行请求的对象）解耦**。
发送者无需知道接收者的具体实现，只需通过命令对象传递请求，命令对象则负责调用接收者的相应方法。

简单来说，**命令模式把 “做什么” 和 “谁去做” 分离开来，用一个中间的命令对象来衔接**，就像日常生活中 “客户下单（命令）→ 厨师做菜（接收者执行）” 的过程，客户无需知道厨师是谁、怎么做。

## 一、定义
命令模式的核心思想是：

将**请求者（Invoker）与执行者（Receiver）解耦，把一个操作封装到命令对象（Command）**中，让调用者只需触发命令，而不用关心命令是如何执行的。

基本角色：

1. Command（命令接口/抽象类）：定义执行命令的接口。
2. ConcreteCommand（具体命令）：实现 Command，绑定一个 Receiver 执行实际动作。
3. Receiver（接收者）：知道如何执行一个请求。
4. Invoker（调用者）：触发命令，但不直接执行。
5. Client（客户端）：创建命令对象并绑定接收者。

## 二、优缺点
✅ 优点
1. 解耦请求者和接收者：调用者不需要知道执行细节。
2. 易于扩展新命令：新增命令类不会影响现有代码，符合开闭原则。
3. 可组合、记录、撤销操作：支持宏命令、历史记录、撤销（Undo）/恢复（Redo）。
4. 参数化请求：命令对象可以携带执行所需的数据。

❌ 缺点

1. 类数量增加：每个命令都需要一个类，可能导致类爆炸。
2. 简单任务会显得繁琐：对于很简单的调用，使用命令模式可能过度设计。
3. 额外的内存开销：存储历史命令、宏命令时会占用更多内存。

## 三、适合解决的问题

命令模式适合：

1. 需要解耦调用者与执行者的场景（如 GUI 按钮与业务逻辑分离）。
2. 需要支持撤销/恢复操作（如编辑器的撤销功能）。
3. 需要将请求排队或记录日志（任务队列、操作历史）。
4. 需要动态组合命令（宏命令，一键执行多个操作）。
5. 需要延迟执行的任务（如定时执行、异步任务）。

💡 简单示例：遥控器控制家电
* Command：开灯命令 / 关灯命令
* Receiver：灯对象（有开、关方法）
* Invoker：遥控器按钮
* Client：创建命令并绑定到按钮
这样，遥控器不关心灯是如何打开的，只需要触发命令即可。

## 命令模式在 OC 中的应用特点
1. 与 Block 结合：在 OC 中，命令对象可以直接用 Block 封装，这样减少类的数量

2. 系统级应用：
* NSUndoManager（撤销/重做）
* NSOperation（任务封装）
* UIControl 的 target-action（某种程度上也是命令模式思想）

3. 业务级应用：
* UI 按钮事件与业务解耦
* 批量任务执行
* 宏命令（一次触发多个操作）


