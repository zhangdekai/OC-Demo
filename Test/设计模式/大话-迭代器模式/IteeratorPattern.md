#  迭代器模Iterator

迭代器模式（Iterator Pattern）是一种行为型设计模式，它的核心思想是：
**在不暴露集合内部实现的前提下，提供一种顺序访问集合中元素的方法。**
简单来说，就是把“遍历集合的逻辑”独立出来，让使用者不必关心集合底层是数组、链表还是其他数据结构。

一、模式定义

迭代器模式定义了一个接口，让外部代码可以按顺序访问集合中的元素，而无需知道集合的内部实现细节。

通常包含两个角色：
1. Iterator（迭代器接口）：定义遍历集合元素的方法（如 hasNext()、next()）。
ConcreteIterator（具体迭代器）：实现迭代器接口，保存遍历状态。

2. Aggregate（聚合接口）：定义获取迭代器的方法。
ConcreteAggregate（具体聚合类）：实现聚合接口，提供具体的迭代器实现。

## 优点
1. 隔离集合与遍历：将集合的遍历逻辑从集合对象中分离出来，符合单一职责原则。
2. 统一遍历接口：无论集合类型如何（数组、链表等），都可以通过相同的迭代器接口遍历，简化了客户端代码。
3. 支持多种遍历方式：一个集合可以提供多个不同的迭代器，实现不同的遍历逻辑（如正序、倒序、过滤等）。
4. 简化集合实现：集合无需关心遍历细节，只需提供创建迭代器的方法。

## 缺点
1. 增加类的数量：每类集合可能需要对应一个迭代器类，增加了系统的复杂度。
2. **遍历过程中修改集合需谨慎**：如果在迭代过程中修改集合（如添加 / 删除元素），可能导致迭代器失效或出现不可预期的结果（需要额外处理，如快速失败机制）。
3. 对简单集合可能过度设计：对于简单的集合（如小型数组），使用迭代器可能显得繁琐。

## 适合解决的问题
1. 需要统一遍历不同集合：当系统中存在多种集合类型（如数组、链表、哈希表），但希望用相同的代码遍历它们时。
2. 不希望暴露集合内部结构：当需要隐藏集合的实现细节（如内部存储方式、索引逻辑）时。
3. 需要多种遍历方式：当集合需要支持多种遍历逻辑（如正序、倒序、按条件筛选）时。
4. 迭代过程中需控制访问：例如实现 "延迟迭代"（按需加载元素）或 "只读迭代"（防止修改元素）。

典型应用场景:
1. Java 中的 Iterator 接口和集合类（ArrayList、HashSet 等）的遍历。
2. Python 中的可迭代对象（iterable）和迭代器（iterator）机制。
3. 数据库查询结果集的遍历（如 JDBC 的 ResultSet）。


迭代器模式的核心价值在于解耦集合与遍历，使得两者可以独立演化，同时提升代码的复用性和可维护性。
