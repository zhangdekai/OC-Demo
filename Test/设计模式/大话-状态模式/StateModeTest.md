##  状态模式

状态模式（State Pattern）是一种行为型设计模式，
**它允许对象在其内部状态改变时改变它的行为，使得对象看起来好像修改了它的类。**

核心思想是将对象的状态抽象为独立的类，并将与该状态相关的行为放在该类中，通过切换状态对象来改变上下文对象的行为，而不是在一个类中用大量的 if/else 或 switch 语句判断状态。

1. 定义
状态模式：允许一个对象在其内部状态改变时改变它的行为，对象看起来好像修改了它的类。 ——《设计模式：可复用面向对象软件的基础》

2. 优点
* 消除复杂条件判断把状态相关的分支逻辑分散到各个状态类中，避免在一个类中堆积大量 if-else 或 switch。
* 更易维护和扩展新增状态只需增加新的状态类，不影响已有代码（符合开闭原则）。
* 状态切换逻辑集中状态之间的切换封装在状态类中，不暴露在外部。

3. 缺点
* 类数量增加每个状态都需要一个类，如果状态很多，类会膨胀。
* 状态切换逻辑可能分散如果切换规则复杂，分散在多个状态类中可能难以追踪。
* 不适合状态很少且不复杂的场景如果状态很少，用 if-else 更直观。

4. 适用场景
* 对象的行为依赖于它的状态，并且运行时需要根据状态改变行为。
* 一个操作中含有大量与状态有关的分支逻辑，并且这些分支逻辑会经常变化。
* 状态切换的规则和行为比较复杂，需要封装管理。

5. 常见例子：
* 工作流：订单状态（已下单、已付款、已发货、已完成）
* 游戏角色：角色状态（待机、攻击、防御、死亡）
* 媒体播放器：播放状态（播放、暂停、停止）
* 文档编辑器：编辑模式、只读模式


代码解析

这个实现包含以下几个核心部分：

**OrderState 协议：定义了所有订单状态需要实现的方法，包括支付、发货、完成和取消等操作**。

**具体状态类：**
* PendingPaymentState（待支付状态）
* PaidState（已支付状态）
* ShippedState（已发货状态）
* CompletedState（已完成状态）
**Order 类**：作为上下文类，持有当前状态的引用，并将所有状态相关的操作委托给当前状态对象处理。
**状态转换逻辑**：每个状态类内部实现了状态转换的规则，例如只有在已支付状态下才能执行发货操作。

这种实现方式**避免了在 Order 类中使用大量的条件判断**，而是将每个状态的行为和状态转换逻辑封装在各自的状态类中，使代码更加清晰、可维护性更高。
