#  享元模式（Flyweight Pattern）

享元模式（Flyweight Pattern）是一种结构型设计模式，

它的核心思想是：**通过共享相同的对象，减少内存占用和对象创建的开销**。

可解释为： 如果系统中存在大量相似的对象，并且这些对象中的大部分状态可以被外部化，那么就可以将这些状态从对象中剥离出来，让多个对象共享同一份数据。这样，就不必为每个对象都创建一个独立的实例，从而大大节省内存。


## ✨ 定义
享元模式运用 共享技术 有效地支持大量细粒度对象的复用。

它把对象分为两类：
* 内部状态（Intrinsic State）：对象内部可以共享、不随环境变化的部分。
* 外部状态（Extrinsic State）：依赖于环境、不能共享的部分，需要从外部传入。

## 核心角色
1. 享元工厂（Flyweight Factory）：管理享元对象，负责创建和复用已有享元。
2. 抽象享元（Flyweight）：定义享元对象的接口，声明内部状态的操作。
3. 具体享元（Concrete Flyweight）：实现抽象享元，存储内部状态，可被共享。
4. 非享元（Unshared Concrete Flyweight）：不参与共享的对象，通常包含外部状态。

## ✅ 优点

1. 减少对象数量，节省内存（适合有大量重复对象的场景）。
2. 降低对象创建开销，提高性能。
3. 提高系统的可扩展性（内部状态和外部状态分离，职责清晰）。
4. 便于管理：集中管理共享对象，统一控制对象的创建和复用。

## ❌ 缺点

1. 逻辑复杂：需要区分内部状态和外部状态，增加了使用难度。
2. 外部状态管理困难：外部状态需要由客户端传入，可能造成调用复杂度上升。
3. 不适合对象差异性很大的场景（共享意义不大），
4. 适用场景有限：仅适用于存在大量相似对象且状态可拆分的场景。

## 🎯 适合解决的问题

1. 系统中存在大量相似对象，导致内存占用过大。
2. 大多数对象的状态可以抽取为共享的内部状态，只有少量状态需要在运行时传入。
3. 对象粒度很小，但数量非常庞大（例如文字处理、地图坐标、游戏对象池等）。 

示例：
1. 围棋 / 象棋程序：棋盘上的棋子（内部状态：颜色、类型；外部状态：位置）。
2. 网页渲染：重复出现的图标或按钮（内部状态：样式；外部状态：位置、事件）。

## 在 Objective-C 中，享元模式的应用非常广泛，
尤其是在需要高效管理大量相似对象以优化性能和内存使用的场景中。以下是一些典型应用场景和实现思路：
1. UI 控件复用（如列表单元格）
UITableView 和 UICollectionView 是享元模式的经典实践。单元格（UITableViewCell）作为享元对象，通过复用机制减少频繁创建和销毁的开销：

内部状态：单元格的样式、布局（可共享部分）。
外部状态：单元格的位置、显示数据（动态变化部分）。

2. 图形渲染（如地图标注、图标）
在地图应用中，大量重复的标注图标（如商店、公交站）可通过享元模式共享：
内部状态：图标图片、默认尺寸（固定不变部分）。
外部状态：经纬度坐标、点击事件（动态变化部分）。

3. 字符串常量池
Objective-C 的 NSString 常量池本质上是享元模式的实现：相同内容的字符串常量会被共享，而非重复创建对象。

4. 配置项管理
应用中全局共享的配置信息（如主题、网络参数）可通过享元工厂统一管理，避免重复加载：
