##  备忘录模式（Memento Pattern）

备忘录模式（Memento Pattern） 是一种行为型设计模式，

**用于在不破坏对象封装性的前提下，捕获并保存对象的内部状态，以便之后将对象恢复到之前的状态。**

它就像一个时光机快照：
1. 你在某个时刻保存状态（保存到 Memento 里）
2. 以后可以回到这个状态（通过 Memento 恢复）


### 一、结构组成

备忘录模式通常有三个角色：
1. Originator（发起人）
* 拥有内部状态
* 可以创建一个备忘录（保存当前状态）
* 可以通过备忘录恢复状态
2. Memento（备忘录）
* 存储 Originator 的内部状态快照
* 不允许外部直接访问其内容（保证封装性）
3. Caretaker（管理者）
* 保存、管理一个或多个备忘录
* 不修改备忘录内容，只负责记录与取回

### 二、优点

1. 保护封装性：状态保存在 Memento 中，不会暴露对象的内部实现细节。
2. 方便恢复：能轻松恢复到历史状态（撤销/回滚功能）。
3. 状态历史记录：可以保存多个历史版本，支持多步撤销。


### 三、缺点

1. 内存开销大：保存多个状态会占用大量内存（尤其是对象状态复杂时）。
2. 性能消耗：频繁保存和恢复可能影响性能。
3. 实现复杂性：状态保存与恢复需要额外的代码和逻辑。


### 四、适用场景
1. 需要撤销（Undo）或回滚功能
2. 文本编辑器的撤销/恢复
3. 游戏中的进度存档
4. 数据库事务回滚
5. 需要保存历史快照
6. 表单编辑中保存草稿
7. 工作流中保存中间状态

Case:
代码解析

在这个实现中，我们构建了一个简单的文本编辑器撤销功能，包含三个核心角色：

1. TextEditor（发起人）：

* 维护文本内容的状态
* 提供createMemento方法创建备忘录
* 提供restoreFromMemento方法从备忘录恢复状态

2. TextMemento（备忘录）：

* 存储文本编辑器的状态（content 属性）
* 通过只读属性保护状态不被随意修改
* 只有发起人可以创建备忘录并访问其完整状态

3. HistoryManager（负责人）：

* 负责保存一系列备忘录
* 提供保存和获取备忘录的接口
* 不了解备忘录的具体内容，也不修改其状态
