#  桥接模式（Bridge Pattern）

桥接模式（Bridge Pattern）是一种结构型设计模式，

它的核心思想是：**将抽象部分与实现部分分离，使它们可以独立变化**。

简单说，就是把一个复杂对象的功能层次（抽象）和实现层次（细节）分开，通过“桥”连接，而不是强耦合地绑在一起。

**桥接模式的本质是： “分离变化维度”，当系统中存在两个独立变化的维度时，使用桥接模式能有效降低耦合，提升灵活性。**


## 一、模式结构

桥接模式主要由以下角色组成：

1. Abstraction（抽象类/接口）

定义高层的抽象接口,持有一个 Implementor（实现者接口）的引用

2. RefinedAbstraction（扩展抽象类）

在 Abstraction 基础上扩展功能

3. Implementor（实现者接口）

定义底层实现接口，但不规定具体实现

4. ConcreteImplementor（具体实现者）
具体的功能实现类

## 二、优点
1. 抽象与实现分离

改抽象不用改实现，改实现也不用改抽象，彼此独立扩展

2. 提高灵活性与可扩展性

任意组合抽象和实现，像搭积木一样

3. 减少类的数量

减少子类数量：**避免抽象类与实现类的多对多组合导致的子类爆炸问题**（例如，若有 2 个抽象类和 3 个实现类，不使用桥接模式需 6 个子类，使用后仅需 5 个）。

4. 符合单一职责原则：抽象层专注于定义业务逻辑，实现层专注于具体操作，各司其职。
**解耦多维度变化：当功能存在两个及以上独立变化的维度（如 “类型 + 实现”“功能 + 平台”），桥接模式可避免类爆炸**


## 三、缺点

1. 结构相对复杂, 抽象层和实现层都要设计接口和实现类

2. 引入额外的层级，增加系统复杂度

3. 增加理解成本，对小型项目可能是“杀鸡用牛刀”

4. 设计难度提升：需要提前梳理抽象与实现的分离点，对设计人员的抽象能力要求较高。

## 四、适用场景

桥接模式特别适合：

1. 抽象与实现都需要独立扩展 
**一个需求可以抽象出多种变化**。
如：形状（圆形、方形） × 颜色（红、蓝、绿）
用桥接可以实现 颜色 与 形状 的独立扩展，而不是形如 RedCircle、BlueSquare 这样爆炸式组合。

2. 避免多层继承导致类数量激增当类的维度有多个（比如设备类型 × 控制方式 × 系统类型）
3. 跨平台应用不同操作系统的 UI、文件系统实现不一样，桥接可以统一抽象接口，底层做平台差异化实现
4. 驱动程序场景硬件抽象（打印机、扫描仪）与不同厂商驱动分离


**示例场景**
以 “消息通知” 为例：（有2种变化的抽象）
* 抽象层：消息（普通消息、紧急消息，X）。
* 实现层：发送方式（短信、邮件、微信，Y）。
* 通过桥接模式，新增 “推送消息” 类型或 “钉钉发送” 方式时，无需修改现有代码，只需新增对应的扩展抽象类或具体实现类即可。

**桥接模式的本质是 “分离变化维度”，当系统中存在两个独立变化的维度时，使用桥接模式能有效降低耦合，提升灵活性。**


代码解析

在这个桥接模式实现中，各个角色对应如下：

1. 实现化接口（Implementor）：MessageSenderProtocol 协议，定义了发送消息的接口

2. 具体实现化（Concrete Implementor）：

* SMSMessageSender：实现短信发送功能
* EmailMessageSender：实现邮件发送功能

3. 抽象化（Abstraction）：**Message 类，持有 MessageSender 引用，定义消息发送的抽象方法**

4. 扩展抽象化（Refined Abstraction）：

* NormalMessage：普通消息，对消息内容进行简单包装
* UrgentMessage：紧急消息，添加特殊标记和额外提醒逻辑

桥接模式的体现：

1. 消息类型（普通 / 紧急）和发送方式（短信 / 邮件）两个维度被分离
2. 可以独立扩展任何一个维度，例如新增 "推送消息" 类型或 "微信发送" 方式
3. 通过 sender 属性建立桥接，使得抽象部分可以调用实现部分的功能
4. 可以在运行时动态切换实现（如示例中紧急消息从邮件发送切换为短信发送）

**这种实现方式避免了消息类型和发送方式的直接耦合，大幅减少了需要的子类数量，提高了系统的灵活性和可扩展性。**


## 在iOS开发中，桥接模式的应用场景有哪些？

在 iOS 开发中，桥接模式的应用场景非常广泛，**尤其适合处理存在多个独立变化维度的业务场景**。

以下是一些典型应用场景：

1. UI 组件与数据 / 主题的解耦

场景：自定义 UI 控件（如按钮、列表）需要适配不同数据格式或主题样式（浅色 / 深色模式、品牌主题）。

桥接体现：

* 抽象层：定义 UI 控件的通用行为（如CustomButton）。
* 实现层：分离出ThemeProtocol（主题实现，负责颜色、字体等）和DataAdapterProtocol（数据适配，负责数据解析）。
* 优势：新增主题或数据格式时，无需修改 UI 控件核心代码。

2. 网络请求与数据解析的分离

场景：同一 API 可能返回 JSON、XML 等不同格式，或需要支持 HTTP、HTTPS、WebSocket 等不同协议。

桥接体现：
* 抽象层：NetworkService定义网络请求的通用接口（如request:parameters:completion:）。
* 实现层：RequestProtocol（处理不同协议的请求发送）和ParserProtocol（处理不同格式的解析）。
* 优势：切换协议或数据格式时，只需替换对应的实现类。

3. 多媒体播放功能

场景：播放器需要支持本地文件、网络流、直播等不同数据源，同时需要适配音频、视频等不同媒体类型。

桥接体现：
* 抽象层：Player定义播放控制接口（播放、暂停、停止）。
* 实现层：DataSourceProtocol（处理不同来源的数据加载）和RendererProtocol（处理音视频渲染）。
* 优势：新增数据源（如蓝牙设备）或渲染方式（如硬件加速）时，不影响播放器核心逻辑。

4. 跨平台功能适配 等
5. 日志系统设计 等

6. 第三方 SDK 适配

场景：同一功能可能集成多个第三方 SDK（如支付功能支持微信、支付宝、Apple Pay）。

桥接体现：

* 抽象层：PaymentService定义支付接口（pay:amount:callback:）。
* 实现层：WeChatPayImpl、AlipayImpl分别对接具体 SDK。
* 优势：替换或新增支付渠道时，业务层代码无需修改。

桥接模式在 iOS 开发中的核心价值

* **解耦多维度变化：当功能存在两个及以上独立变化的维度（如 “类型 + 实现”“功能 + 平台”），桥接模式可避免类爆炸**。
* 提升扩展性：符合开闭原则，新增维度实现时无需修改现有代码。
* 适配 iOS 生态特性：尤其适合处理 Apple 平台的多设备适配、系统版本兼容等问题。
例如，iOS 系统中的**UIView与CALayer的关系本质上也是一种桥接**：UIView负责事件处理（抽象层），CALayer负责渲染（实现层），两者独立变化却通过桥接协同工作。 

