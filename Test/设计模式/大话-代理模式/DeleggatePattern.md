# 代理模式（Proxy Pattern）

代理模式（Proxy Pattern）定义

代理模式是一种结构型设计模式，**它通过引入一个代理对象来控制对目标对象的访问。
代理对象可以在目标对象的功能基础上添加额外操作（如权限校验、日志记录、延迟加载等），而无需修改目标对象的代码**。

它的本质还是那句话：

**在不改变真实对象的前提下，通过代理控制或增强访问过程**。

核心角色：
1. 抽象主题（Protocol）：定义目标对象和代理对象的共同接口。
2. 目标对象（Real Subject）：实现抽象主题，是真正执行业务逻辑的对象。
3. 代理对象（Proxy）：实现抽象主题，持有目标对象的引用，在调用目标对象方法前后可添加额外逻辑。

## 优点
1. 控制访问
可以在调用真实对象之前或之后做权限判断、访问限制等，例如某个对象只能被特定用户使用。

2. 延迟加载（Lazy Loading）
通过代理先占位，等到真正需要的时候才创建和加载真实对象，节省资源。

3. 增强功能
在不修改真实对象代码的情况下，添加日志、缓存、监控等功能（类似 AOP 思路）。

4. 解耦
客户端只需要知道代理接口，不必关心真实对象的创建和复杂逻辑，降低依赖。

## 二、缺点
1. 增加复杂度
需要额外维护代理类结构，代码层次变多。

2. 性能开销
多了一层调用转发，性能会稍微下降（在高频调用场景要注意）。

3. 一致性风险
如果代理逻辑和真实对象逻辑不一致，可能会导致数据或行为异常。

## 应用：Flutter 中：
ImageProvider / NetworkImage / AssetImage
作用：ImageProvider 是一个抽象类，NetworkImage、AssetImage 等都是它的实现。

代理模式体现：
Image widget 并不直接去加载网络图片或本地资源，而是通过一个 ImageProvider 代理去获取数据。
这个代理负责：缓存（ImageCache）,延迟加载, 解码

好处：调用方不需要关心图片从哪里来、怎么加载，只要交给代理类。

## 代理模式的应用场景
1. 虚拟代理（Virtual Proxy）
延迟加载重量级对象，如大图像、视频、数据库连接。
例子：ImageProxy 先显示占位图，等图片下载完成再显示真图。

2. 保护代理（Protection Proxy）
控制对对象的访问权限，比如只有管理员可以调用某方法。

3. 远程代理（Remote Proxy）
代理代表一个在远程服务器上的对象，客户端像调用本地对象一样访问它（RPC、Web Service）。

4. 缓存代理（Cache Proxy）
代理负责缓存数据，如果已有缓存就直接返回，减少真实对象调用次数。

5. 监控代理（Monitoring Proxy）
用于统计调用次数、耗时等性能指标。

6. UITableviewDelegate , UICollectionDellegate

## 中介者模式和代理模式有什么区别？
都是用于解耦的重要模式。

代理模式是 **结构型设计模式**，为单个对象提供一个替代者（代理），通过代理控制对原对象的访问（如权限校验、延迟加载、日志记录）

中介者模式，是一种**行为设计模式**，解决多个对象之间的复杂交互问题，通过引入 “中介者”，让所有对象不再直接通信，而是通过中介者间接交互.

