#  职责链模式（Chain of Responsibility Pattern）

职责链模式（Chain of Responsibility Pattern）是一种行为型设计模式，
**它通过将多个处理对象 按顺序连接成一条链，让请求沿着链传递，直到被某个对象处理为止**。

这种模式的**核心思想是解耦请求的发送者和接收者，使得发送者不必关心请求最终由谁处理**。

把一连串的处理逻辑解耦成独立的节点，按顺序传递处理请求。

## 1. 定义

职责链模式将一系列可能处理请求的对象连接成一条链，请求沿着这条链传递，直到遇到能够处理它的对象。每个节点对象只关心自己能否处理，不能处理就传递给下一个节点。

## 2. 结构
典型组成：
1. Handler（抽象处理者）：定义处理请求的接口，并包含指向下一个处理者的引用。
2. ConcreteHandler（具体处理者）：实现处理逻辑，**如果不能处理，就交给下一个处理者**。
3. Client（客户端）：创建职责链并发送请求。


## 3. 优点
✅ 降低耦合度
发送者不需要知道接收者是谁、顺序如何，只管发送请求。
✅ 动态组合处理流程
可以在运行时灵活调整处理者顺序或新增处理者。
✅ 符合开闭原则
新增处理者只需实现接口并加入链中，无需改动已有代码。
✅ 增强灵活性
请求可以被链上的一个或多个处理者处理。

## 4. 缺点
⚠ 可能导致调试困难
请求可能经过多个处理者，调试和定位问题不直观。
⚠ 处理链过长影响性能
如果链很长且没有合适的处理者，请求可能传遍整个链。
⚠ 处理顺序受链结构影响
顺序错了可能导致处理结果不符合预期。

## 5. 适合解决的问题
职责链模式适合：
1. 多个对象都有可能处理同一请求，但具体由谁处理不确定（例如审批流程、事件分发、日志处理）。
2. 需要在运行时灵活指定处理流程（动态改变处理者顺序或内容）。
3. 避免在请求发送者中使用大量 if/else 判断（用链替代条件分支）。

## 6. 示例场景
1. 审批流：普通员工提交请假申请 → 部门经理审批 → HR 审批 → 总经理审批。
2. 日志处理：日志信息依次经过 Debug → Info → Error → 文件记录器。
3. Web 请求过滤器：身份验证 → 日志记录 → 数据压缩 → 业务处理。

## 职责链模式的两种实现方式
职责链的 “链结构” 可通过两种方式实现，适用于不同的业务需求：
1. 纯职责链（Strict Chain）

规则：每个处理者必须满足 “要么处理请求，要么传递给下一个处理者”，不允许 “部分处理后传递” 或 “不处理也不传递”。
适用场景：请求只能由一个处理者处理（如报销审批，一笔报销只能由一个角色审批通过）。

2. 不纯职责链（Non-Strict Chain）

规则：处理者可选择 “部分处理请求后传递给下一个处理者”，或 “处理后仍传递”（多个处理者共同处理一个请求）。
适用场景：请求需要多个处理者协同处理（如 HTTP 拦截器：登录拦截器验证登录状态后，权限拦截器继续验证权限，日志拦截器记录请求信息，所有拦截器都需执行）。
## 总结

职责链模式的核心价值是解耦与灵活：通过 “链” 的结构让请求自主传递，避免发送者与处理者的直接依赖，同时支持动态调整处理逻辑。但需注意避免 “链过长导致性能损耗” 和 “请求丢失” 的问题，建议在链的末端设置 “默认处理逻辑”（如提示 “请求无法处理”），并控制链的长度（一般不超过 5 个处理者）。

在实际开发中，职责链模式广泛应用于**拦截器、过滤器、审批流程等场景，是解决 “多处理者协作” 问题的经典方案**。

代码说明

1. 抽象处理者 (AbstractApprover)：
* 定义了审批者的基本接口，包含一个指向下一个审批者的引用
* 提供了初始化方法和抽象的审批方法

2. 具体处理者：
* TeamLeader：处理 1000 元及以下的报销
* DepartmentManager：处理 1001-5000 元的报销
* CEO：处理 5001-20000 元的报销

3. 职责链的构建：
* 在客户端代码中，我们创建了各个处理者对象并通过nextApprover属性构建了链式结构
* 形成了 "组长→部门经理→CEO" 的审批链

4. 请求处理流程：
* 每个处理者判断自己是否能处理当前请求
* 如果能处理则直接处理，否则传递给下一个处理者
* 直到找到能处理的对象或到达链的末端


## 在 iOS 开发中，职责链模式有着广泛的应用，既存在于系统框架中，也常用于业务逻辑实现。以下是一些典型场景：

1. UI 事件响应链（Responder Chain）
这是 iOS 中最经典的职责链模式实现。
原理：UI 事件（如点击、滑动）会沿着「响应者链」传递，从最上层的视图（如按钮）开始，依次向上传递给父视图、视图控制器、窗口（UIWindow），直到应用对象（UIApplication）。

职责链角色：

*  抽象处理者：UIResponder（所有能响应事件的对象基类，定义了nextResponder属性和touchesBegan:withEvent:等事件处理方法）。
* 具体处理者：UIView、UIViewController、UIWindow、UIApplication等，每个对象判断是否处理事件，若不处理则通过nextResponder传递给下一个响应者。
* 示例：点击一个按钮时，事件先由按钮处理；若按钮不处理（如未设置点击事件），则传递给父视图，以此类推。

2. UI 手势识别器（UIGestureRecognizer）的优先级链

3. 网络请求拦截器（自定义实现）
* 场景：统一处理请求头（如添加 Token）、请求参数加密、缓存策略、错误重试等。

4. 表单验证逻辑
* 处理复杂表单（多张表单，审批）时，可通过职责链按顺序验证各字段：

5. 消息转发机制（Message Forwarding）
虽然消息转发更偏向「责任链的变种」，但其核心思想类似
