## 策略模式（Strategy Pattern）

装饰模式（Decorator Pattern）是一种结构型设计模式，
**它允许你在不修改原有类的情况下，动态地为对象添加额外的功能。**
它通过将对象放入一个“包装器”对象中来实现，这个包装器实现相同的接口，并在调用前后添加新的行为。

核心思想
**“用对象包装对象，动态叠加功能，而不是用继承一次性写死功能。”**


结构组成
Component（组件接口）定义对象的统一接口，原始对象和装饰对象都实现它。
ConcreteComponent（具体组件）原始的、最基础的功能类。
Decorator（抽象装饰类）持有一个 Component 对象的引用，并实现 Component 接口，负责功能扩展的骨架。
ConcreteDecorator（具体装饰类）在调用原始功能前后添加额外功能。


优点
✅ 不改变原类：不用修改已有类的源码，符合开闭原则。
✅ 灵活组合：可以任意组合不同装饰类，功能叠加很灵活。
✅ 替代继承：相比多层继承结构更轻量、可维护性更高。

缺点
⚠ 调试复杂：多层嵌套装饰时，调用链可能很长，不容易追踪问题。
⚠ 创建大量小对象：每一层装饰都是一个对象，可能增加内存消耗。
⚠ 顺序敏感：装饰顺序不同，结果可能不同。

适合解决的场景
需要动态为对象添加功能，并且功能可能在运行时才确定。
不想通过继承来扩展类（避免类爆炸问题）。
希望用多种功能组合生成不同的行为，而不是为每种组合建一个子类。

简单例子（现实类比）
比如咖啡订单：
原始类：Espresso（基础咖啡）
装饰类：MilkDecorator（加牛奶）、SugarDecorator（加糖）
你可以组合 SugarDecorator(MilkDecorator(Espresso)) 来得到加糖加奶的咖啡。

