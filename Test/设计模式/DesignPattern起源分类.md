#  设计模式（Design Patterns）

设计模式（Design Patterns）的诞生源于面向对象编程（OOP）发展过程中对 “可复用、可维护、灵活扩展” 软件设计的探索。

1994 年，**《设计模式：可复用面向对象软件的基础》（简称 “GOF 书”）**
由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版，首次系统总结了 23 种经典设计模式，并按其解决的核心问题分为创建型、结构型、行为型三大类。

这三类模式的诞生，**分别对应了面向对象编程中对象创建、结构组织、行为协作三个核心场景**的痛点解决方案。

## 一、创建型模式：解决 “对象创建的 耦合与复杂性” 问题 

诞生背景：

在面向对象编程早期，开发者通常直接通过new关键字创建对象（如User user = new User()），这种方式会导致 **“对象的使用” 与 “对象的创建逻辑” 紧耦合 **：
* 若需要切换对象类型（如从MySQLUser改为OracleUser），需修改所有new的地方，违反 “开闭原则”；
* 复杂对象的创建（如包含多个组件、依赖关系的对象）会导致创建逻辑臃肿，与业务逻辑混杂，难以维护；
* 部分场景需要控制对象的创建过程（如单例、池化对象、延迟初始化），直接创建无法满足。

核心解决思路：

**创建型模式通过封装对象的创建逻辑，将 “对象的创建” 与 “对象的使用” 分离，让使用者无需关心具体创建细节，只需通过统一接口获取对象。**

典型模式：

单例模式（Singleton）、工厂方法（Factory Method）、抽象工厂（Abstract Factory）、建造者（Builder）、原型（Prototype）。

## 二、结构型模式：解决 “类与对象的组合结构臃肿与灵活性不足” 问题

诞生背景：

面向对象编程中，类与对象的结构关系（如继承、组合）直接影响系统的灵活性。早期设计中，过度依赖继承导致 “类爆炸” 和 “脆弱性”：

1. 多层继承会使类之间形成强耦合（父类修改会影响所有子类），且功能复用受限（继承是 “is-a” 关系，无法灵活组合多个独立功能）；
2. 不同接口的类难以协同工作（如旧系统接口与新系统接口不兼容）；
3. 复杂结构（如树形结构、嵌套对象）的组织缺乏清晰的复用方式，导致代码冗余。

核心解决思路：

**结构型模式通过优化类与对象的组合方式（优先使用 “组合” 而非 “继承”），解决结构上的兼容性、复用性问题，让系统结构更灵活、更易于扩展。**

典型模式：

适配器（Adapter）、桥接（Bridge）、装饰器（Decorator）、组合（Composite）、外观（Facade）、享元（Flyweight）、代理（Proxy）。

## 三、行为型模式：解决 “对象间交互的混乱与耦合” 问题

诞生背景：

当系统中多个对象需要协作完成任务时，直接的硬编码交互（如 A 对象直接调用 B 对象的方法）会导致 “交互逻辑混乱” 和 “对象间强耦合”：

1. 一个对象的修改可能引发多个关联对象的连锁修改（如 “订单提交” 需要通知库存、支付、日志等对象，直接调用会导致订单类与这些类紧耦合）；
2. 对象间的职责划分不清晰，导致行为逻辑分散，难以复用和维护；
3. 复杂的交互流程（如状态切换、命令执行）缺乏标准化的组织方式，可读性差。

核心解决思路：

**行为型模式通过规范对象间的交互方式，明确职责划分，减少直接依赖，让对象间的协作更清晰、更灵活（可动态切换交互逻辑）。**

典型模式：

观察者（Observer）、策略（Strategy）、命令（Command）、状态（State）、责任链（Chain of Responsibility）、迭代器（Iterator）、模板方法（Template Method）等。

## 总结：三类模式的诞生逻辑

三类模式的诞生，本质上是对面向对象编程三大核心要素的优化：

* 创建型：聚焦 “对象的创建”，解决 “创建逻辑与使用逻辑的耦合”；
* 结构型：聚焦 “类与对象的组合”，解决 “结构臃肿与复用困难”；
* 行为型：聚焦 “对象间的交互”，解决 “协作混乱与职责不清”。

它们共同的目标是提升软件的可复用性、可维护性和灵活性，是面向对象设计从 “经验” 到 “方法论” 的里程碑式总结。


## 系统化整理：GoF (Gang of four) 的经典定义
1994 年，“四人组”（GoF）在《设计模式：可复用面向对象软件的基础》中，将结构性设计模式作为三大类设计模式之一（另外两类是创建型、行为型），系统定义了 7 种经典模式：

!(结构性设计模式)(/结构性设计模式.png)


/Users/zhangdekai/Documents/GitHub/OC-Bottom-Data-algorithm/Test/设计模式/结构性设计模式.png

这些模式的提出，标志着结构性设计模式从零散的实践经验上升为系统化的理论。它们的诞生并非孤立，而是与当时软件系统的发展需求紧密结合：例如，随着分布式系统的兴起，远程代理模式成为处理跨进程通信的重要工具；随着内存受限设备（如早期嵌入式系统）的普及，享元模式通过共享对象解决了资源紧张问题。

