##  观察者模式

观察者模式是一种行为型设计模式，

它**定义了一种一对多 的依赖关系，让多个观察者对象在被观察对象（主题）的状态发生变化时，能够自动收到通知并更新**。

通俗理解： “一个人打喷嚏（被观察者状态改变），周围的人（观察者）立刻作出反应”。

## 结构组成
观察者模式主要有两类角色：

1. Subject（主题/被观察者）
维护一个观察者列表
提供注册、移除、通知观察者的方法

2. Observer（观察者）
定义一个接口，当主题状态发生变化时执行更新

## 优缺点
优点：
1. 松耦合：被观察者和观察者之间无需相互了解具体实现，仅通过抽象接口通信，降低了模块间的依赖。
2. 可扩展性强：新增观察者时无需修改被观察者代码，符合 “开闭原则”。
3. 动态联动：可灵活添加 / 移除观察者，实现状态变化的动态响应。

## 适用场景
1. 一个对象的变化需要引起其他对象的同步变化
2. 事件驱动系统（UI 事件、消息系统）
3. 发布-订阅模型（类似 NotificationCenter）
4. MVC 中，Model 变化需要通知 View 更新
5. 数据与视图联动：当模型数据更新时，多个视图（如列表、图表）需同步刷新。
6. 消息通知机制：如系统通知、状态广播（如网络状态变化时通知所有相关模块）。

## 观察者模式在iOS开发中的应用场景:

一、ios 系统框架本身就大量采用了这一模式，同时开发者也经常基于它实现模块间的解耦通信.

1. UI 控件事件监听
如UIButton的点击事件、UISlider的滑动事件、UISwitch的状态切换等。通过addTarget:action:forControlEvents:方法注册观察者（通常是视图控制器），当控件状态变化时，会主动通知观察者执行对应方法。
2. KVO（Key-Value Observing）KVO 是 iOS 中观察者模式的经典实现，用于监听对象属性的变化。当被观察对象的属性值改变时，观察者会收到observeValueForKeyPath:ofObject:change:context:回调。 
3. 常见场景：
* 监听模型数据变化，同步更新 UI（如网络请求数据返回后刷新列表）。
* 监控系统状态（如电池电量、网络状态的NSNotification本质上也基于类似思想）。

二. 数据与视图的联动（MVC/MVVM 架构）

在 iOS 主流架构中，观察者模式是实现 “数据驱动 UI” 的核心机制：
1. MVC 模式中模型（Model）与视图（View）的同步当模型数据（如用户信息、列表数据）发生变化时，通过观察者模式通知视图（或视图控制器）更新 UI，避免视图直接依赖模型的内部逻辑。

2. 网络请求成功后，模型数据更新，通过代理或通知通知 ViewController 刷新 TableView。

3. MVVM 模式中 ViewModel 与 View 的绑定ViewModel 持有数据并暴露可观察的属性（如使用RACSignal、Combine或自定义观察者），View 订阅这些属性的变化，自动更新界面。

4. 使用Combine框架时，View 通过assign(to:on:)订阅 ViewModel 的属性，实现 UI 的自动同步。

三. 通知中心（NSNotificationCenter/NotificationCenter）

iOS 的NotificationCenter是观察者模式的 “广播式” 实现，支持一对多、跨模块的通信，发布者和订阅者完全解耦：
 1.跨层级通信
当两个无直接引用关系的组件需要通信时（如 AppDelegate 与某个页面、不同 Tab 页之间），通过通知中心传递消息。

2. 常见场景：
* 登录状态变化（登录成功后，通知各页面更新用户信息）。
* 系统事件（如应用进入后台、内存警告，通过UIApplicationDidEnterBackgroundNotification等系统通知响应）。
* 自定义业务事件（如购物车商品数量变化，通知导航栏徽章更新）。

四. 手势与动画状态监听

1.手势识别（UIGestureRecognizer）
手势识别器本身是被观察者，当检测到手势（如滑动、捏合、旋转）时，会通知注册的观察者（通常是视图控制器）执行对应操作。

2. 动画状态监听使用UIView动画或CAAnimation时，通过设置代理（UIViewAnimationDelegate、CAAnimationDelegate）监听动画的开始、结束或暂停状态，在回调中执行后续逻辑（如动画结束后跳转页面）。
五. 网络状态与推送通知

1. 网络状态变化监听通过Reachability框架或系统NWPathMonitor监听网络状态（Wi-Fi / 蜂窝网络 / 无网络），当状态变化时，通知相关模块（如提示用户 “网络已断开”、暂停视频播放）。

2. 远程推送与本地通知应用接收远程推送（APNs）或本地通知时，通过UNUserNotificationCenterDelegate的回调（观察者方法）处理通知内容（如跳转指定页面、展示弹窗）。

六. 自定义业务场景中的解耦

1. 在复杂业务中，开发者常自定义观察者模式解决模块间依赖问题：
多视图联动例如，一个页面中有多个关联的控件（如开关 A 开启后，输入框 B 才可用），通过自定义观察者模式让控件间相互响应，避免在控制器中写大量耦合逻辑。

2. 状态机管理当业务存在复杂状态转换（如订单状态：待支付→已支付→已发货→已完成），通过观察者模式让各相关模块（订单列表、详情页、消息中心）实时响应状态变化。

3. 插件化 / 组件化通信在组件化架构中，不同组件通过 “事件总线”（基于观察者模式的自定义实现）通信，避免组件间直接依赖（如登录组件登录成功后，通过事件总线通知其他组件）。
## 总结

观察者模式在 iOS 开发中无处不在，其核心价值是解耦—— 让消息的发送者和接收者相互独立，提高代码的可维护性和扩展性。无论是系统原生的 KVO、NotificationCenter，还是业务层的自定义实现，都围绕这一核心思想解决 “状态变化的联动响应” 问题。实际开发中，需根据场景选择合适的实现方式（如简单联动用代理，跨模块用通知，数据绑定用 KVO/Combine 等）。
  

