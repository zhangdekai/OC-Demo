##  大话-简单工厂VS工厂方法模式Factory

工厂方法模式是一种创建型设计模式，
**它定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。
工厂方法让类的实例化推迟到子类中进行。**

## 核心角色
1. 抽象工厂（Abstract Factory）：声明创建产品的接口（工厂方法）
2. 具体工厂（Concrete Factory）：实现抽象工厂的方法，具体创建产品
3. 抽象产品（Abstract Product）：定义产品的接口
4. 具体产品（Concrete Product）：实现抽象产品接口，由具体工厂创建

## 优点
1. 遵循开闭原则：新增产品时只需添加对应的具体产品类和具体工厂类，无需修改现有代码
2. 单一职责原则：每个具体工厂只负责创建对应的产品
3. 解耦：将产品的创建和使用分离，客户端无需知道具体产品的类名，只需知道对应的工厂
4. 提高灵活性：可以在运行时通过选择不同的工厂来创建不同的产品

## 缺点
1. 类数量增加：每增加一个产品，就需要增加一个具体产品类和一个具体工厂类，可能导致类数量过多
2. 复杂度提高：引入了抽象层，增加了系统的抽象性和理解难度
3. 客户端需要知道工厂：客户端需要知道哪个工厂生产哪种产品，才能正确使用

## 适合解决的问题
1. 产品种类不确定：当系统需要支持多种产品，且未来可能会添加新的产品类型时
2. 创建对象复杂：当对象的创建过程复杂，需要封装创建逻辑时
3. 解耦创建与使用：希望将产品的创建和使用分离，降低客户端与具体产品的耦合度
4. 框架设计：在框架设计中，需要让框架的使用者能够扩展框架的功能（如日志框架、UI 组件库等）

**例如：**
* 日志系统（可以通过不同工厂创建文件日志、数据库日志等）、
* 文档编辑器（不同工厂创建不同类型的文档元素）、
* UI 组件库（不同主题工厂创建对应主题的组件）等场景都适合使用工厂方法模式。

## 在OC 中的应用

OC 中的 类方法(+)初始化方法, 主要采用的 工厂方法模式 来动态的创建初始化对象。

1. 框架中的经典应用Cocoa 框架中大量使用工厂方法模式，例如：
* [NSNumber numberWithInt:10]：NSNumber 类通过不同工厂方法创建不同类型的数值对象
* [UIButton buttonWithType:UIButtonTypeSystem]：UIButton 通过工厂方法创建不同类型的按钮
* [NSArray arrayWithObjects:]：集合类的便捷构造方法本质上也是工厂方法

2. OC 特有的 “类簇”（Class Cluster）模式类簇是OC中工厂方法模式的一种高级实现，
通过隐藏具体子类，对外暴露统一的抽象接口。例如：

* NSString、NSArray、NSDictionary 等集合类都是类簇，实际创建的是其内部私有子类的实例
* 调用 [NSString stringWithFormat:@"%d", 10] 时，系统会根据参数自动选择最合适的具体子类


# 简单工厂 VS 工厂方法模式

简单工厂模式实现:

简单工厂模式**通过一个工厂类来创建所有产品对象，客户端通过传递参数来获取不同的产品实例**。

工厂方法模式实现:

工厂方法模式**为每个产品提供一个对应的工厂类，所有工厂类实现同一个工厂接口，客户端通过具体工厂来获取产品实例**。

简单工厂模式和工厂方法模式都是创建型设计模式，用于封装对象的创建过程，更换对象时不需要大的改动就可实现，降低客户端和产品对象的耦合。 工厂方法模式是简单工厂的进一步抽象和优化（开闭原则）

但它们在实现方式和灵活性上有显著区别：

核心结构不同

1. 简单工厂模式：
只有一个工厂类（通常是静态类），负责创建所有类型的产品
产品类型通过参数（如枚举、字符串）来指定
结构简单：一个工厂类 + 多个产品类（实现同一接口）

2. 工厂方法模式：
为每个产品类型创建对应的工厂类
所有工厂类实现同一个工厂接口
结构更复杂：一个工厂接口 + 多个工厂实现类 + 多个产品类


扩展方式不同
1. 简单工厂模式：
新增产品时，需要修改工厂类的逻辑（添加新的判断分支）
违反 "开闭原则"（对扩展开放，对修改关闭）

2. 工厂方法模式：
新增产品时，只需添加对应的产品类和工厂类，无需修改现有代码
完全符合 "开闭原则"

适用场景不同
1. 简单工厂模式：
适合产品种类较少且变化不频繁的场景
例如：日志工具（控制台日志、文件日志）、简单计算器（加减乘除）

2. 工厂方法模式：
适合产品种类较多或可能频繁新增产品的场景
例如：图形编辑器（圆形、矩形、三角形等）、数据库访问层（MySQL、Oracle、SQL Server）

简单工厂模式的最大优点在于 工厂类中包含了必要的判断逻辑，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。

工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单的内部逻辑判断移动到了客户端代码来进行，想要增加功能，本来是修改工厂类的，而现在是修改客户端。



